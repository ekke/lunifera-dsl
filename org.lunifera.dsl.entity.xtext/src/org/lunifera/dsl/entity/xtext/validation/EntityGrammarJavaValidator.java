/*
 * generated by Xtext
 */
package org.lunifera.dsl.entity.xtext.validation;

import java.util.HashSet;
import java.util.Set;

import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.resource.IContainer;
import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.validation.NamesAreUniqueValidator;
import org.eclipse.xtext.validation.ValidationMessageAcceptor;
import org.lunifera.dsl.entity.xtext.extensions.ModelExtensions;
import org.lunifera.dsl.semantic.common.types.LAttribute;
import org.lunifera.dsl.semantic.common.types.LDataType;
import org.lunifera.dsl.semantic.common.types.LFeature;
import org.lunifera.dsl.semantic.common.types.LPackage;
import org.lunifera.dsl.semantic.common.types.LType;
import org.lunifera.dsl.semantic.common.types.LunTypesPackage;
import org.lunifera.dsl.semantic.entity.EntityPackage;
import org.lunifera.dsl.semantic.entity.LBeanReference;
import org.lunifera.dsl.semantic.entity.LEntity;
import org.lunifera.dsl.semantic.entity.LEntityModel;
import org.lunifera.dsl.semantic.entity.LEntityReference;

import com.google.inject.Inject;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
public class EntityGrammarJavaValidator extends
		AbstractEntityGrammarJavaValidator {

	public static final String BASE = "org.lunifera.dsl.entity.";
	public static final String CASCADE_NOT_VALID = BASE + "cascadeNotValid";

	public static final String CODE__DUPLICATE_LPACKAGE_IN_PROJECT = "100";
	public static final String CODE__DUPLICATE_LTYPE_IN_PROJECT = "101";
	public static final String CODE__DUPLICATE_LPACKAGE_IN_FILE = "102";
	public static final String CODE__MANY_TO_MANY__NOT_SUPPORTED = "103";

	@Inject
	IQualifiedNameProvider qnp;
	@Inject
	ModelExtensions extensions;
	@Inject
	NamesAreUniqueValidator uniqueValidator;
	@Inject
	IContainer.Manager containermanager;
	@Inject
	ResourceDescriptionsProvider resourceDescriptionsProvider;

	@Check
	public void checkDatatype_asPrimitive(LDataType dt) {
		super.checkDatatype_asPrimitive(dt);
	}

	@Check
	public void checkJPA_MultiHasOppositeReference(LEntityReference prop) {
		if (extensions.isToMany(prop) && prop.getOpposite() == null) {
			error("A bidirectional association needs an opposite reference.",
					EntityPackage.Literals.LENTITY_REFERENCE__OPPOSITE);
		}
	}

	@Check
	public void checkBean_MultiHasOppositeReference(LBeanReference prop) {
		if (extensions.isToMany(prop) && prop.getOpposite() == null) {
			error("A bidirectional association needs an opposite reference.",
					EntityPackage.Literals.LBEAN_REFERENCE__OPPOSITE);
		}
	}

	@Check
	public void checkJPA_OppositeNotAlsoCascading(LEntityReference prop) {
		if (prop.getOpposite() != null) {
			if (prop.isCascading() && prop.getOpposite().isCascading()) {
				error("Only one opposite may be specified as cascade",
						LunTypesPackage.Literals.LREFERENCE__CASCADING);
			}

			if (extensions.isToMany(prop.getOpposite())) {
				if (prop.isCascading()) {
					error("The many-to-one relation must not be marked as cascade",
							prop,
							LunTypesPackage.Literals.LREFERENCE__CASCADING,
							CASCADE_NOT_VALID, new String[0]);
				}
			}
		}
	}

	@Check
	public void checkBean_OppositeNotAlsoCascading(LBeanReference prop) {
		if (prop.getOpposite() != null) {
			if (prop.isCascading() && prop.getOpposite().isCascading()) {
				error("Only one opposite may be specified as cascade",
						LunTypesPackage.Literals.LREFERENCE__CASCADING);
			}

			if (extensions.isToMany(prop.getOpposite())) {
				if (prop.isCascading()) {
					error("The many-to-one relation must not be marked as cascade",
							prop,
							LunTypesPackage.Literals.LREFERENCE__CASCADING,
							CASCADE_NOT_VALID, new String[0]);
				}
			}
		}
	}

	// ### @Check
	// public void checkJPA_ContainsHasOppositeReference(LContainer container) {
	// if (container.getOpposite() == null) {
	// warning("A container reference should have an opposite reference too. Otherwise the annotation type (ManyToOne or OneToOne) can not be determined!",
	// EntityPackage.Literals.LCONTAINER__OPPOSITE);
	// }
	// }

	// @Check
	// public void checkJPA_NotNull_LRefernce_OneToMany_NotNull_NotAllowed(
	// LReference lReference) {
	//
	// if (lReference instanceof LRefers) {
	// LRefers lRefers = (LRefers) lReference;
	// if (lRefers.isNotnull()) {
	// EntityBounds bounds = EntityBounds.createFor(lRefers
	// .getMultiplicity());
	// if (bounds.isToMany()) {
	// error("Modifier 'notnull' is not allowed for references with upper bound GREATER ONE",
	// EntityPackage.Literals.LREFERS__NOTNULL);
	// }
	// }
	// } else if (lReference instanceof LContains) {
	// LContains lContains = (LContains) lReference;
	// if (lContains.isNotnull()) {
	// EntityBounds bounds = EntityBounds.createFor(lContains
	// .getMultiplicity());
	// if (bounds.isToMany()) {
	// error("Modifier 'notnull' is not allowed for containment references with upper bound GREATER ONE",
	// EntityPackage.Literals.LCONTAINS__NOTNULL);
	// }
	// }
	// }
	// }

	@Check
	public void checkJPA_ID_LEntityHasOnlyOneId(LEntity entity) {
		int idCount = 0;
		int memberIndex = -1;
		int firstIdIndex = -1;
		for (LFeature prop : entity.getFeatures()) {
			memberIndex++;
			if (prop instanceof LAttribute) {
				LAttribute p = (LAttribute) prop;
				if (p.isId()) {
					idCount++;
					if (firstIdIndex == -1) {
						firstIdIndex = memberIndex;
					}
				}
			}
		}

		if (idCount == 0) {
			if (entity.getSuperType() == null) {
				warning("An entity should have an ID property",
						EntityPackage.Literals.LENTITY__FEATURES);
			}
		} else if (idCount > 1) {
			error("An entity must only have one ID property",
					EntityPackage.Literals.LENTITY__FEATURES, memberIndex);
		}
	}

	// @Check
	// public void checkJPA_ID_SpecifiedBySuperclass(LEntity entity) {
	// // only check jpa model
	// if (!extensions.compilesToJPAModel(entity)) {
	// return;
	// }
	//
	// LClass superType = entity.getSuperType();
	// if (superType == null) {
	// return;
	// }
	//
	// boolean idFoundForSuperType = doesSupertypeContainIdProperty(entity);
	//
	// // lookup if an id property exists in the entity
	// int memberIndex = -1;
	// boolean idFound = false;
	// for (LFeature prop : entity.getProperties()) {
	// memberIndex++;
	// if (prop instanceof LFeature) {
	// LFeature p = (LFeature) prop;
	// if (p.isId()) {
	// idFound = true;
	// break;
	// }
	// }
	// }
	//
	// if (idFoundForSuperType && !idFound) {
	// // nothing to do!
	// }
	//
	// if (idFoundForSuperType && idFound) {
	// warning("A id property was already defined by the super type. You should remove it here.",
	// EntityPackage.Literals.LENTITY__PROPERTIES,
	// memberIndex);
	// }
	//
	// if (!idFoundForSuperType && !idFound) {
	// warning("Nor the entity or one of its super types define an id property. Check the type hierarchy.",
	// EntityPackage.Literals.LENTITY__PROPERTIES);
	// }
	// }
	//
	// /**
	// * Returns true, if any of the supertypes contains an id property.
	// *
	// * @param superType
	// * @return
	// */
	// private boolean doesSupertypeContainIdProperty(LEntity entity) {
	// LEntity superType = entity.getSuperType();
	// if (superType == null) {
	// return false;
	// }
	// boolean idFoundForSuperType = false;
	// for (LFeature prop : superType.getProperties()) {
	// if (prop instanceof LFeature) {
	// LFeature p = (LFeature) prop;
	// if (p.isId()) {
	// idFoundForSuperType = true;
	// break;
	// }
	// }
	// }
	//
	// if (!idFoundForSuperType) {
	// idFoundForSuperType = doesSupertypeContainIdProperty(superType);
	// }
	//
	// return idFoundForSuperType;
	// }
	//
	// /**
	// * Returns true, if any of the supertypes contains an id property.
	// *
	// * @param superType
	// * @return
	// */
	// private boolean doesSupertypeContainVersionProperty(LEntity entity) {
	// LEntity superType = entity.getSuperType();
	// if (superType == null) {
	// return false;
	// }
	// boolean versionFoundForSuperType = false;
	// for (LFeature prop : superType.getProperties()) {
	// if (prop instanceof LFeature) {
	// LFeature p = (LFeature) prop;
	// if (p.isVersion()) {
	// versionFoundForSuperType = true;
	// break;
	// }
	// }
	// }
	//
	// if (!versionFoundForSuperType) {
	// versionFoundForSuperType =
	// doesSupertypeContainVersionProperty(superType);
	// }
	//
	// return versionFoundForSuperType;
	// }
	//
	// @Check
	// public void checkJPA_Version_SpecifiedBySuperclass(LEntity entity) {
	// if (entity.getSuperType() == null) {
	// return;
	// }
	//
	// boolean versionContainedInSuperType =
	// doesSupertypeContainVersionProperty(entity);
	//
	// int memberIndex = -1;
	// boolean versionFound = false;
	// for (LFeature prop : entity.getProperties()) {
	// memberIndex++;
	// if (prop instanceof LFeature) {
	// LFeature p = (LFeature) prop;
	// if (p.isVersion()) {
	// versionFound = true;
	// break;
	// }
	// }
	// }
	//
	// if (versionContainedInSuperType && versionFound) {
	// warning("A version property was already defined in one of the super types.",
	// EntityPackage.Literals.LENTITY__PROPERTIES,
	// memberIndex);
	// }
	// }
	//
	// @Check
	// public void checkJPA_Version_LEntityHasOnlyOneVersion(LEntity entity) {
	// int versionCount = 0;
	// int memberIndex = -1;
	// for (LFeature prop : entity.getProperties()) {
	// memberIndex++;
	// if (prop instanceof LFeature) {
	// LFeature p = (LFeature) prop;
	// if (p.isVersion()) {
	// versionCount++;
	// }
	// }
	// }
	//
	// if (versionCount > 1) {
	// error("An entity must only have one version property",
	// EntityPackage.Literals.LENTITY__PROPERTIES,
	// memberIndex);
	// }
	// }
	//
	// private boolean isStringValid(String value) {
	// return value != null && !value.equals("");
	// }

	@Check
	public void checkProperties_JavaKeyWord(LFeature lprop) {
		super.checkProperties_JavaKeyWord(lprop);
	}

	@Check
	public void checkDuplicatePackages_InFile(LEntityModel lmodel) {
		Set<String> names = new HashSet<String>();
		int counter = -1;
		for (LPackage pkg : lmodel.getPackages()) {
			counter++;
			String pkgName = qnp.getFullyQualifiedName(pkg).toString();
			if (names.contains(pkgName)) {
				error(String.format("Package %s must not be defined twice!",
						pkgName),
						EntityPackage.Literals.LENTITY_MODEL__PACKAGES,
						counter, CODE__DUPLICATE_LPACKAGE_IN_FILE,
						(String[]) null);
			}
			names.add(pkgName);
		}
	}

	@Check(CheckType.NORMAL)
	public void checkDuplicateType_InProject(LType type) {
		super.checkDuplicateType_InProject(type);
	}

	@Check(CheckType.NORMAL)
	public void checkDuplicatePackage_InProject(LPackage lPackage) {
		super.checkDuplicatePackage_InProject(lPackage);
	}

	@Check
	public void checkManyToMany(LEntityReference prop) {
		ModelExtensions extension = new ModelExtensions();
		if (prop.getOpposite() != null && extension.isToMany(prop)
				&& extension.isToMany(prop.getOpposite())) {
			error(String.format("ManyToMany relations are not permitted!", qnp
					.getFullyQualifiedName(prop).toString()), prop.getEntity(),
					EntityPackage.Literals.LENTITY__FEATURES,
					ValidationMessageAcceptor.INSIGNIFICANT_INDEX,
					CODE__MANY_TO_MANY__NOT_SUPPORTED, (String[]) null);
		}
	}
}
