/*
 * generated by Xtext
 */
package org.lunifera.dsl.entity.xtext.validation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.resource.IContainer;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.resource.IResourceDescription;
import org.eclipse.xtext.resource.IResourceDescriptions;
import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.validation.NamesAreUniqueValidator;
import org.eclipse.xtext.validation.ValidationMessageAcceptor;
import org.lunifera.dsl.entity.xtext.extensions.ModelExtensions;
import org.lunifera.dsl.semantic.common.types.LAttribute;
import org.lunifera.dsl.semantic.common.types.LDataType;
import org.lunifera.dsl.semantic.common.types.LFeature;
import org.lunifera.dsl.semantic.common.types.LPackage;
import org.lunifera.dsl.semantic.common.types.LType;
import org.lunifera.dsl.semantic.common.types.LunTypesPackage;
import org.lunifera.dsl.semantic.entity.EntityPackage;
import org.lunifera.dsl.semantic.entity.LBeanReference;
import org.lunifera.dsl.semantic.entity.LDiscriminatorType;
import org.lunifera.dsl.semantic.entity.LEntity;
import org.lunifera.dsl.semantic.entity.LEntityInheritanceStrategy;
import org.lunifera.dsl.semantic.entity.LEntityModel;
import org.lunifera.dsl.semantic.entity.LEntityPersistenceInfo;
import org.lunifera.dsl.semantic.entity.LEntityReference;
import org.lunifera.dsl.semantic.entity.LTablePerClassStrategy;
import org.lunifera.dsl.semantic.entity.LTablePerSubclassStrategy;

import com.google.inject.Inject;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
public class EntityGrammarJavaValidator extends
		AbstractEntityGrammarJavaValidator {

	public static final String BASE = "org.lunifera.dsl.entity.";
	public static final String CASCADE_NOT_VALID = BASE + "cascadeNotValid";

	public static final String CODE__DUPLICATE_LPACKAGE_IN_PROJECT = "100";
	public static final String CODE__DUPLICATE_LTYPE_IN_PROJECT = "101";
	public static final String CODE__DUPLICATE_LPACKAGE_IN_FILE = "102";
	public static final String CODE__MANY_TO_MANY__NOT_SUPPORTED = "103";
	public static final String CODE__DIFFERING_INHERITANCE_FROM_SUPERTYPE = "104";
	public static final String CODE__INHERITANCE_PROPERTY_IGNORED = "105";
	public static final String CODE__INHERITANCE_DISCRIMINATOR_VALUE_NOT_UNIQUE = "106";
	public static final String CODE__DUPLICATE_PERSISTENCE = "106";

	@Inject
	IQualifiedNameProvider qnp;
	@Inject
	ModelExtensions extensions;
	@Inject
	NamesAreUniqueValidator uniqueValidator;
	@Inject
	IContainer.Manager containermanager;
	@Inject
	ResourceDescriptionsProvider resourceDescriptionsProvider;

	@Check
	public void checkDatatype_asPrimitive(LDataType dt) {
		super.checkDatatype_asPrimitive(dt);
	}

	@Check
	public void checkJPA_MultiHasOppositeReference(LEntityReference prop) {
		if (extensions.isToMany(prop) && prop.getOpposite() == null) {
			error("A bidirectional association needs an opposite reference.",
					EntityPackage.Literals.LENTITY_REFERENCE__OPPOSITE);
		}
	}

	@Check
	public void checkBean_MultiHasOppositeReference(LBeanReference prop) {
		if (extensions.isToMany(prop) && prop.getOpposite() == null) {
			error("A bidirectional association needs an opposite reference.",
					EntityPackage.Literals.LBEAN_REFERENCE__OPPOSITE);
		}
	}

	@Check
	public void checkJPA_OppositeNotAlsoCascading(LEntityReference prop) {
		if (prop.getOpposite() != null) {
			if (prop.isCascading() && prop.getOpposite().isCascading()) {
				error("Only one opposite may be specified as cascade",
						LunTypesPackage.Literals.LREFERENCE__CASCADING);
			}

			if (extensions.isToMany(prop.getOpposite())) {
				if (prop.isCascading()) {
					error("The many-to-one relation must not be marked as cascade",
							prop,
							LunTypesPackage.Literals.LREFERENCE__CASCADING,
							CASCADE_NOT_VALID, new String[0]);
				}
			}
		}
	}

	@Check
	public void checkBean_OppositeNotAlsoCascading(LBeanReference prop) {
		if (prop.getOpposite() != null) {
			if (prop.isCascading() && prop.getOpposite().isCascading()) {
				error("Only one opposite may be specified as cascade",
						LunTypesPackage.Literals.LREFERENCE__CASCADING);
			}

			if (extensions.isToMany(prop.getOpposite())) {
				if (prop.isCascading()) {
					error("The many-to-one relation must not be marked as cascade",
							prop,
							LunTypesPackage.Literals.LREFERENCE__CASCADING,
							CASCADE_NOT_VALID, new String[0]);
				}
			}
		}
	}

	@Check
	public void checkJPA_ID_LEntityHasOnlyOneId(LEntity entity) {
		int idCount = 0;
		int memberIndex = -1;
		int firstIdIndex = -1;
		for (LFeature prop : entity.getFeatures()) {
			memberIndex++;
			if (prop instanceof LAttribute) {
				LAttribute p = (LAttribute) prop;
				if (p.isId()) {
					idCount++;
					if (firstIdIndex == -1) {
						firstIdIndex = memberIndex;
					}
				}
			}
		}

		if (idCount == 0) {
			if (entity.getSuperType() == null) {
				warning("An entity should have an ID property",
						EntityPackage.Literals.LENTITY__FEATURES);
			}
		} else if (idCount > 1) {
			error("An entity must only have one ID property",
					EntityPackage.Literals.LENTITY__FEATURES, memberIndex);
		}
	}

	@Check
	public void checkProperties_JavaKeyWord(LFeature lprop) {
		super.checkProperties_JavaKeyWord(lprop);
	}

	@Check
	public void checkDuplicatePackages_InFile(LEntityModel lmodel) {
		Set<String> names = new HashSet<String>();
		int counter = -1;
		for (LPackage pkg : lmodel.getPackages()) {
			counter++;
			String pkgName = qnp.getFullyQualifiedName(pkg).toString();
			if (names.contains(pkgName)) {
				error(String.format("Package %s must not be defined twice!",
						pkgName),
						EntityPackage.Literals.LENTITY_MODEL__PACKAGES,
						counter, CODE__DUPLICATE_LPACKAGE_IN_FILE,
						(String[]) null);
			}
			names.add(pkgName);
		}
	}

	@Check(CheckType.NORMAL)
	public void checkDuplicateType_InProject(LType type) {
		super.checkDuplicateType_InProject(type);
	}

	@Check(CheckType.NORMAL)
	public void checkDuplicatePackage_InProject(LPackage lPackage) {
		super.checkDuplicatePackage_InProject(lPackage);
	}

	@Check
	public void checkManyToMany(LEntityReference prop) {
		ModelExtensions extension = new ModelExtensions();
		if (prop.getOpposite() != null && extension.isToMany(prop)
				&& extension.isToMany(prop.getOpposite())) {
			error(String.format("ManyToMany relations are not permitted!", qnp
					.getFullyQualifiedName(prop).toString()), prop.getEntity(),
					EntityPackage.Literals.LENTITY__FEATURES,
					ValidationMessageAcceptor.INSIGNIFICANT_INDEX,
					CODE__MANY_TO_MANY__NOT_SUPPORTED, (String[]) null);
		}
	}

	@Check(CheckType.NORMAL)
	public void checkJPA_ConsistentInheritanceStrategy(LEntity entity) {
		// no checks required - inheritance is inherited
		if (entity.getInheritanceStrategy() == null) {
			return;
		}

		LEntityInheritanceStrategy differingSuperStgy = searchDifferingSuperStrategy(
				entity.getInheritanceStrategy(), entity);
		if (differingSuperStgy != null) {
			LEntity superType = (LEntity) differingSuperStgy.eContainer();
			warning(String.format(
					"The supertype %s uses the inheritance strategy %s. The inheritance of this entity is ignored!",
					qnp.getFullyQualifiedName(superType).toString(),
					getStrategyName(differingSuperStgy)),
					EntityPackage.Literals.LENTITY__INHERITANCE_STRATEGY,
					ValidationMessageAcceptor.INSIGNIFICANT_INDEX,
					CODE__DIFFERING_INHERITANCE_FROM_SUPERTYPE, (String[]) null);
		}
	}

	protected String getStrategyName(LEntityInheritanceStrategy stgy) {
		if (LTablePerClassStrategy.class.isAssignableFrom(stgy.getClass())) {
			return "Table-Per-Class";
		} else {
			return "Table-Per-Subclass";
		}
	}

	protected LEntityInheritanceStrategy searchDifferingSuperStrategy(
			LEntityInheritanceStrategy stgy, LEntity entity) {
		LEntity superEntity = entity.getSuperType();
		if (superEntity == null) {
			return null;
		}

		LEntityInheritanceStrategy superStgy = superEntity
				.getInheritanceStrategy();
		if (superStgy == null) {
			return searchDifferingSuperStrategy(stgy, superEntity);
		}

		if (!stgy.getClass().getName().equals(superStgy.getClass().getName())) {
			return superStgy;
		}

		return searchDifferingSuperStrategy(stgy, superEntity);
	}

	@Check(CheckType.NORMAL)
	public void checkJPA_IgnoredInheritanceStrategyProperties(LEntity entity) {
		// no checks required - inheritance is inherited
		LEntityInheritanceStrategy stgy = entity.getInheritanceStrategy();
		if (stgy == null) {
			return;
		}

		if (entity.getSuperType() != null
				&& !extensions.checkIsMappedSuperclass(entity.getSuperType())) {
			if (LTablePerClassStrategy.class.isAssignableFrom(stgy.getClass())) {
				LTablePerClassStrategy castStgy = (LTablePerClassStrategy) stgy;
				if (castStgy.getDiscriminatorColumn() != null) {
					sendIgnoredInheritancePropertyWarning(
							stgy,
							EntityPackage.Literals.LTABLE_PER_CLASS_STRATEGY__DISCRIMINATOR_COLUMN);
				}
				if (castStgy.getDiscriminatorType() != LDiscriminatorType.INHERIT) {
					sendIgnoredInheritancePropertyWarning(
							stgy,
							EntityPackage.Literals.LTABLE_PER_CLASS_STRATEGY__DISCRIMINATOR_TYPE);
				}
			} else {
				LTablePerSubclassStrategy castStgy = (LTablePerSubclassStrategy) stgy;
				if (castStgy.getDiscriminatorColumn() != null) {
					sendIgnoredInheritancePropertyWarning(
							stgy,
							EntityPackage.Literals.LTABLE_PER_SUBCLASS_STRATEGY__DISCRIMINATOR_COLUMN);
				}
				if (castStgy.getDiscriminatorType() != LDiscriminatorType.INHERIT) {
					sendIgnoredInheritancePropertyWarning(
							stgy,
							EntityPackage.Literals.LTABLE_PER_SUBCLASS_STRATEGY__DISCRIMINATOR_TYPE);
				}
			}
		}
	}

	@Check(CheckType.NORMAL)
	public void checkJPA_InheritanceStrategy_NotUniqueDiscriminatorValue(
			LEntity entity) {
		if (entity.getSuperType() == null) {
			return;
		}

		String currentValue = extensions.toDiscriminatorValue(extensions
				.toInheritanceStrategy(entity));

		// collect all super type strategies
		List<LEntityInheritanceStrategy> stgies = extensions
				.collectAllInheritanceStrategies(entity.getSuperType());

		for (LEntityInheritanceStrategy stgy : stgies) {
			String value = extensions.toDiscriminatorValue(stgy);
			if (value.equals(currentValue)) {
				error(String.format(
						"The discrimator value %s is already used by supertype!",
						value), entity,
						EntityPackage.Literals.LENTITY__INHERITANCE_STRATEGY,
						ValidationMessageAcceptor.INSIGNIFICANT_INDEX,
						CODE__INHERITANCE_DISCRIMINATOR_VALUE_NOT_UNIQUE,
						(String[]) null);
			}
		}
	}

	@Check(CheckType.NORMAL)
	public void checkDuplicatePersistentFQN_InProject(LEntity entity) {
		LEntityPersistenceInfo info = entity.getPersistenceInfo();
		if (info == null) {
			return;
		}
		Map<IContainer, List<LEntityPersistenceInfo>> lTypes = getAllPersistentFQNsFor(info);
		for (Map.Entry<IContainer, List<LEntityPersistenceInfo>> temp : lTypes
				.entrySet())
			if (temp.getValue().size() > 1) {
				error(String.format("Persistence type %s is already defined!", qnp
						.getFullyQualifiedName(info).toString()), entity,
						EntityPackage.Literals.LENTITY__PERSISTENCE_INFO,
						ValidationMessageAcceptor.INSIGNIFICANT_INDEX,
						CODE__DUPLICATE_PERSISTENCE, (String[]) null);
			}
	}

	private void sendIgnoredInheritancePropertyWarning(
			LEntityInheritanceStrategy stgy, EAttribute att) {
		warning("Inherited from parent entity. Will be ignored.", stgy, att,
				ValidationMessageAcceptor.INSIGNIFICANT_INDEX,
				CODE__DIFFERING_INHERITANCE_FROM_SUPERTYPE, (String[]) null);
	}

	public Map<IContainer, List<LEntityPersistenceInfo>> getAllPersistentFQNsFor(
			LEntityPersistenceInfo info) {
		Map<IContainer, List<LEntityPersistenceInfo>> allEntities = new HashMap<IContainer, List<LEntityPersistenceInfo>>();
		IResourceDescriptions resourceDescriptions = resourceDescriptionsProvider
				.getResourceDescriptions(info.eResource());
		IResourceDescription resourceDescription = resourceDescriptions
				.getResourceDescription(info.eResource().getURI());
		List<IContainer> visiblecontainers = containermanager
				.getVisibleContainers(resourceDescription, resourceDescriptions);
		for (IContainer container : visiblecontainers) {
			List<LEntityPersistenceInfo> types = new ArrayList<LEntityPersistenceInfo>();
			allEntities.put(container, types);
			for (IEObjectDescription eObjectDescription : container
					.getExportedObjects(
							EntityPackage.Literals.LENTITY_PERSISTENCE_INFO,
							qnp.getFullyQualifiedName(info), true)) {
				types.add((LEntityPersistenceInfo) eObjectDescription
						.getEObjectOrProxy());
			}
		}
		return allEntities;
	}
}
