/**
 * Copyright (c) 2011 - 2012, Florian Pirchner - lunifera.org
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Sources generated by Xtext  
 * 
 * Contributors:
 *  		Florian Pirchner - Initial implementation
 */
package org.lunifera.dsl.entity.xtext.jvmmodel.services.jpa

import com.google.inject.Inject
import org.eclipse.xtext.common.types.util.TypeReferences
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.lunifera.dsl.entity.semantic.model.LCompilerType
import org.lunifera.dsl.entity.semantic.model.LContains
import org.lunifera.dsl.entity.semantic.model.LEntity
import org.lunifera.dsl.entity.semantic.model.LEntityModel
import org.lunifera.dsl.entity.semantic.model.LEnum
import org.lunifera.dsl.entity.semantic.model.LGenSettings
import org.lunifera.dsl.entity.semantic.model.LOperation
import org.lunifera.dsl.entity.semantic.model.LProperty
import org.lunifera.dsl.entity.semantic.model.LReference
import org.lunifera.dsl.entity.xtext.extensions.ModelExtensions
import org.lunifera.dsl.entity.xtext.jvmmodel.services.IEntityJvmModelInferrerDelegate
import org.lunifera.dsl.entity.xtext.jvmmodel.services.entity.EntityTypesBuilder

/**
 * Difference to EntityJvmModelInferrerDelegate:<br>
 * Embedds references are not inlined. They are treated as simple references and annotated with @java.persistence.Embedds
 */
class JPAJvmModelInferrerDelegate implements IEntityJvmModelInferrerDelegate {
	
    /**
     * conveninence API to build and initialize JvmTypes and their members.
     */
	@Inject extension EntityTypesBuilder 
	@Inject extension IQualifiedNameProvider
	@Inject extension ModelExtensions
	@Inject TypeReferences references
	 
	override isResponsible(LCompilerType lCompilerType) {
		lCompilerType.compilesToJPAModel
	}
	
   		/**
	 * Is called for each instance of the first argument's type contained in a resource.
	 * 
	 * @param element - the model to create one or more JvmDeclaredTypes from.
	 * @param acceptor - each created JvmDeclaredType without a container should be passed to the acceptor in order get attached to the
	 *                   current resource.
	 * @param isPreLinkingPhase - whether the method is called in a pre linking phase, i.e. when the global index isn't fully updated. You
	 *        must not rely on linking using the index if iPrelinkingPhase is <code>true</code>
	 */
	 @SuppressWarnings({"deprecation"})
   	 override void infer(LEntity e, IJvmDeclaredTypeAcceptor acceptor, boolean isPrelinkingPhase) {
   	 	val LEntityModel model = e.getPackage().eContainer as LEntityModel
   	 	val LGenSettings settings = model.genSettings
		acceptor.accept(
 			e.toEntityClass( e.fullyQualifiedName, settings)
			).initializeLater [
				documentation = e.documentation
				if (e.superType != null && !e.superType.fullyQualifiedName.toString.empty) {
					superTypes += references.getTypeForName(e.superType.fullyQualifiedName.toString, e, null)
				}

				members += e.toConstructor() []
					
				if(settings.lifecycleHandling && e.superType == null){
					members += e.toPrimitiveTypeField("disposed", Boolean::TYPE)
				}
				//
				// fields
				//
				for ( f : e.entityMembers ) {
					switch f {
						LProperty: {
							members += f.toField(f.name, f.toTypeReference())
						}
						
						LReference: {
							if(f.fullyQualifiedName != null && !f.fullyQualifiedName.toString.empty){
								members += f.toField(f.name, f.toTypeReference())
							}
						}
					}
				}
				
				//
				// methods
				//
				if(settings.lifecycleHandling){
					if(e.superType == null){
						members += e.toIsDisposed()
					}
					members += e.toCheckDisposed()
					members += e.toDispose()
				}
				
				for ( f : e.entityMembers ) {
					switch f {
						LProperty : {
							members += f.toGetter(f.name, settings)
							if (f.toMany) {
								members += f.toInternalCollectionGetter(f.name)
								members += f.toAdder(f.name, settings)	
								members += f.toRemover(f.name, settings)		
							} else {
								members += f.toSetter(f.name, settings)
							}
						}
						
						LReference : {
							members += f.toGetter(f.name, settings)
							if (f.toMany) {
								members += f.toInternalCollectionGetter(f.name)
								members += f.toAdder(f.name, settings)
								members += f.toRemover(f.name, settings)
								members += f.toInternalAdder(f.name, settings)
								members += f.toInternalRemover(f.name, settings)
							} else {
								members += f.toSetter(f.name, settings)

								if (f instanceof LContains && (f as LContains).opposite != null) {
									members += f.toInternalSetter
								}
							}
						}
						
						LOperation: {
							members += f.toMethod(f.name, f.type) [
								documentation = f.documentation
								for (p : f.params) {
									parameters += p.toParameter(p.name, p.parameterType)
								}
								body = f.body
							]
						}
					}
				}
			]
   	}
   	
   	/**
	 * Is called for each instance of the first argument's type contained in a resource.
	 * 
	 * @param element - the model to create one or more JvmDeclaredTypes from.
	 * @param acceptor - each created JvmDeclaredType without a container should be passed to the acceptor in order get attached to the
	 *                   current resource.
	 * @param isPreLinkingPhase - whether the method is called in a pre linking phase, i.e. when the global index isn't fully updated. You
	 *        must not rely on linking using the index if iPrelinkingPhase is <code>true</code>
	 */
	 @SuppressWarnings({"deprecation"})
   	 override void infer(LEnum e, IJvmDeclaredTypeAcceptor acceptor, boolean isPrelinkingPhase) {
		acceptor.accept(
 			e.toEnumerationType(e.fullyQualifiedName.toString, null)
			).initializeLater [
				documentation = e.documentation
				//
				// literals
				//
				for ( f : e.literals ) {
					documentation = f.documentation
					members+=f.toEnumerationLiteral(f.name)
				}
			]
   	}
}